<#@ assembly name="System.Data"        #>
<#@ import namespace="System.Data"     #>
<#@ import namespace="System.Text.RegularExpressions"     #>
<#@ import namespace="LinqToDB.Data"   #>
<#@ include file="DataModel.ttinclude" #>
<#
	if (BaseDataContextClass == null)
		BaseDataContextClass = "LinqToDB.Data.DataConnection";
#>
<#+
Action BeforeGenerateLinqToDBModel = () => {};
Action AfterGenerateLinqToDBModel  = () => {};

Func<Table,MemberBase> GenerateProviderSpecificTable = t => null;

bool GenerateObsoleteAttributeForAliases = false;
bool GenerateFindExtensions = true;
bool IsCompactColumns       = true;
bool IsCompactColumnAliases = true;
bool GenerateDataTypes      = false;
bool GenerateDbTypes        = false;
bool GenerateSchemaAsType   = false;
bool IsOracle   = false;

string SchemaNameSuffix          = "Schema";
string SchemaDataContextTypeName = "DataContext";


Dictionary<string,string> ShardingTables = new Dictionary<string,string>();

Dictionary<string,string> SchemaNameMapping = new Dictionary<string,string>();
string ToPascalCase(string the_string)
{
	//如果是sharing table的话 约定好是 带有 { 和 } 符号的

	//if(the_string.Contains("{") && the_string.Contains("}"))
	//{
	//	Regex rgx = new Regex("\\{.*\\}");
	//	the_string = rgx.Replace(the_string, "");
    //}

    // If there are 0 or 1 characters, just return the string.
    if (the_string == null) return the_string;
    if (the_string.Length < 2) return the_string.ToUpper();

    // Split the string into words.
    string[] words = the_string.Split(
        new char[] {'_' },
        StringSplitOptions.RemoveEmptyEntries);

    // Combine the words.
    string result = "";
    foreach (string word in words)
    {
        result +=
            word.Substring(0, 1).ToUpper() +
            (IsOracle?word.Substring(1).ToLower():word.Substring(1));
    }

    return result;
}
void GenerateTypesFromMetadata()
{
	BeforeGenerateLinqToDBModel();
	Model.Usings.Add("System.Linq");
	Model.Usings.Add("AntData.ORM");
	Model.Usings.Add("AntData.ORM.Mapping");
	Model.Usings.Add("AntData.ORM.Linq");
	if (NamespaceName == null)
		NamespaceName = "DataModel";

	string schemaName;

	var schemas =
	(
		from t in Tables.Values
		where GenerateSchemaAsType && t.Schema != null && !t.TableSchema.IsDefaultSchema
		group t by t.Schema into gr
		let typeName = SchemaNameMapping.TryGetValue(gr.Key, out schemaName) ? schemaName : gr.Key
		select new
		{
			Name            = gr.Key,
			TypeName        = typeName + SchemaNameSuffix,
			PropertyName    = typeName,
			Props           = new MemberGroup { IsCompact = true },
			Aliases         = new MemberGroup { IsCompact = true, Region = "Alias members" },
			TableExtensions = new MemberGroup { Region = "Table Extensions" },
			Type            = new Class(typeName + SchemaNameSuffix) { IsStatic = true },
			Tables          = gr.ToList(),
			DataContext     = new Class(SchemaDataContextTypeName),
		}
	).ToDictionary(t => t.Name);

	var defProps           = new MemberGroup { IsCompact = true };
	var defAliases         = new MemberGroup { IsCompact = true, Region = "Alias members" };
	var defTableExtensions = new MemberGroup { };

	if (GenerateConstructors)
	{
		var body = new List<string>();
		body.Add("this.con = con;");

	    DataContextObject.Members.Add(new Field("IDataContext", "con")
	    {
	        AccessModifier = AccessModifier.Private,
	        IsReadonly = true
	    });
		
		DataContextObject.Members.Add(new Method(null, "IQueryable<T> Get<T>", null, new List<string>{"return this.con.GetTable<T>();"}) { AfterSignature = { " where T : class" }  });
		DataContextObject.Members.Add(new Method(null, DataContextObject.Name, new[] { "IDataContext con" }, body) {  });
		
	}

	if (Tables.Count > 0)
		DataContextObject.Members.Insert(0, defProps);

	foreach (var schema in schemas.Values)
	{
		schema.Type.Members.Add(schema.DataContext);
		schema.DataContext.Members.Insert(0, schema.Props);

		schema.DataContext.Members.Add(new Field ("IDataContext", "_dataContext") { AccessModifier = AccessModifier.Private, IsReadonly = true });
		schema.DataContext.Members.Add(new Method(null, schema.DataContext.Name, new[] { "IDataContext dataContext" }, new[] { "_dataContext = dataContext;" }));

		foreach (var t in schema.Tables)
		{
			t.TypePrefix = schema.TypeName + ".";
		}
	}

	foreach (var t in Tables.Values.OrderBy(tbl => tbl.IsProviderSpecific).ThenBy(tbl=> tbl.TypeName))
	{
		if(t.Columns.Values.Count == 0) continue;
		if(ShardingTables.ContainsKey(t.TableName))
		{
			 t.TypeName = ToPascalCase(ShardingTables[t.TableName]);//按照约定 sharding table的情况 必须是 _{?}的格式
        }else{
			 t.TypeName = ToPascalCase(t.TypeName);
        }
	   
		Action<Class> addType = tp => Model.Types.Add(tp);
		var props             = defProps;
		var aliases           = defAliases;
		var tableExtensions   = defTableExtensions;

		var schema = t.Schema != null && schemas.ContainsKey(t.Schema) ? schemas[t.Schema] : null;

		if (schema != null)
		{
			var si = schemas[t.Schema];

			addType         = tp => si.Type.Members.Add(tp);
			props           = si.Props;
			aliases         = si.Aliases;
			tableExtensions = si.TableExtensions;
		}

	MemberBase dcProp = t.IsProviderSpecific ?
			GenerateProviderSpecificTable(t) :
			new Property(
				string.Format("IQueryable<{0}>", ToPascalCase(t.TypeName)),
				ShardingTables.ContainsKey(t.TableName)?ToPascalCase(t.TypeName):ToPascalCase(t.DataContextPropertyName),
				new[] { string.Format((schema == null ? "this" : "_dataContext") + ".Get<{0}>()", ToPascalCase(t.TypeName)) },
				null);

		if (dcProp == null) continue;

		t.DataContextProperty = dcProp;

		props.Members.Add(dcProp);

		Property aProp = null;

		if (t.AliasPropertyName != null && t.AliasPropertyName != t.DataContextPropertyName)
		{
			aProp = new Property(
				string.Format("IQueryable<{0}>", t.TypeName),
				t.AliasPropertyName,
				new[] { t.DataContextPropertyName },
				null);
			
			if (GenerateObsoleteAttributeForAliases)
				aProp.Attributes.Add(new Attribute("Obsolete", "\"Use " + t.DataContextPropertyName + " instead.\""));

			aliases.Members.Add(aProp);
		}

		var tableAttrs = new List<string>();

		if (DatabaseName != null) tableAttrs.Add("Database=" + '"' + DatabaseName + '"');
		if (t.Schema     != null) tableAttrs.Add("Schema="   + '"' + t.Schema     + '"');
		if (!string.IsNullOrEmpty(t.Description )) tableAttrs.Add("Comment="   + '"' + t.Description  + '"');

		tableAttrs.Add((tableAttrs.Count == 0 ? "" : "Name=") + '"' + t.TableName + '"');

		t.Attributes.Add(new Attribute("Table", tableAttrs.ToArray()) { IsSeparated = true } );

		if (t.IsView)
			t.Comment.Add(" View");

		var comments = new List<string>();

		if (!string.IsNullOrWhiteSpace(t.Description))
		{
			comments.Add("/ <summary>");
			foreach (var line in t.Description.Split('\n'))
				comments.Add("/ " + line.TrimEnd());
			comments.Add("/ </summary>");
		}

		if (comments.Count > 0)
		{
			t.     Comment.AddRange(comments);
			dcProp.Comment.AddRange(comments);

			if (aProp != null)
				aProp.Comment.AddRange(comments);
		}

		var columns        = new MemberGroup { IsCompact = IsCompactColumns , Region = "Column"  };
		var columnAliases  = new MemberGroup { IsCompact = IsCompactColumnAliases, Region = "Alias members" };
		var spcialColumn  = new MemberGroup { IsCompact = true, Region = "Field" };
		var nPKs           = t.Columns.Values.Count(c => c.IsPrimaryKey);
		var allNullable    = t.Columns.Values.All  (c => c.IsNullable || c.IsIdentity);
		var nameMaxLen     = t.Columns.Values.Max  (c => c.MemberName != c.ColumnName ? 0 : c.ColumnName.Length);
		var dbTypeMaxLen   = t.Columns.Values.Max  (c => c.ColumnType.Length);
		var dataTypeMaxLen = t.Columns.Values.Max  (c => c.DataType.Length);

		foreach (var c in t.Columns.Values)
		{
			//if(new string[]{"Tid","DataChange_LastTime"}.Contains(c.ColumnName)) continue;
			// 字段.
			//
			var ca = new Attribute("Column");
			var canBeReplaced = true;

			if (c.MemberName == c.ColumnName)
			{
				var space = new string(' ', nameMaxLen - c.ColumnName.Length);

				ca.Parameters.Add('"' + c.ColumnName + '"' + space);
				canBeReplaced = false;
			}
			else if (nameMaxLen > 0)
			{
				ca.Parameters.Add(new string(' ', nameMaxLen + 2));
				canBeReplaced = false;
			}
			c.ColumnName = ToPascalCase(c.ColumnName);
			if(c.ColumnName == ToPascalCase(t.TypeName))
			{
				c.ColumnName = c.ColumnName + "S";
			}
			c.MemberName = c.ColumnName;
			if (GenerateDbTypes)
			{
				var space = new string(' ', dbTypeMaxLen - c.ColumnType.Length);

				ca.Parameters.Add("DbType=\"" + c.ColumnType + '"' + space);
				canBeReplaced = false;
			}

			if (GenerateDataTypes)
			{
				var space = new string(' ', dataTypeMaxLen - c.DataType.Length);

				ca.Parameters.Add("DataType=" + c.DataType + space);

				if (c.Length    != null) ca.Parameters.Add("Length="    + (c.Length == int.MaxValue ? "int.MaxValue" : c.Length.ToString()));
				if (c.Precision != null) ca.Parameters.Add("Precision=" + c.Precision);
				if (c.Scale     != null) ca.Parameters.Add("Scale="     + c.Scale);

				canBeReplaced = false;
			}

			if (c.SkipOnInsert && !c.IsIdentity)
			{
				ca.Parameters.Add("SkipOnInsert=true");
				canBeReplaced = false;
			}

			if (c.SkipOnUpdate && !c.IsIdentity)
			{
				ca.Parameters.Add("SkipOnUpdate=true");
				canBeReplaced = false;
			}
			if (!string.IsNullOrEmpty(c.Description))
			{
				ca.Parameters.Add("Comment=\"" + c.Description + '"');
			}
			c.Attributes.Add(ca);

			// 主键PK.
			//
			if (c.IsPrimaryKey)
			{
				var pka = new Attribute("PrimaryKey");

				if (nPKs > 1)
					pka.Parameters.Add(c.PrimaryKeyOrder.ToString());

				if (canBeReplaced)
					c.Attributes[0] = pka;
				else
					c.Attributes.Add(pka);

				canBeReplaced = false;
			}

			// 自增Identity.
			//
			if (c.IsIdentity)
			{
				var ida = new Attribute("Identity");

				if (canBeReplaced)
					c.Attributes[0] = ida;
				else
					c.Attributes.Add(ida);

				canBeReplaced = false;
			}

			// Nullable.
			//
			if (c.IsNullable)
            {
				c.Attributes.Add(new Attribute((allNullable ? "" : "   ") + "Nullable"));
            }
			else if (!c.IsIdentity)
            {
			   //非空类型
				c.Attributes.Add(new Attribute("NotNull"));
				//如果还是DateTime类型的话 给个默认值
				//spcialColumn
				if(c.Type == "DateTime"){
					c.IsAuto = false;
					c.GetBody.AddRange(new[] { "_" + c.MemberName });
					c.SetBody.AddRange(new[] { "_" +c.MemberName + " = value;"});
					var dt = new Field(c.Type,"_" +c.ColumnName);
					dt.InitValue = "System.Data.SqlTypes.SqlDateTime.MinValue.Value";
					//dt.IsReadonly = true;
					dt.AccessModifier = AccessModifier.Private;
					spcialColumn.Members.Add(dt);
                }
				
            }

			var columnComments = new List<string>();

			if (!string.IsNullOrWhiteSpace(c.Description))
			{
				columnComments.Add("/ <summary>");
				foreach (var line in c.Description.Split('\n'))
					columnComments.Add("/ " + line.TrimEnd());
				columnComments.Add("/ </summary>");
			}

			if (columnComments.Count > 0)
				c.Comment.AddRange(columnComments);

			// End line comment.
			//
			c.EndLineComment = c.ColumnType;

			SetPropertyValue(c, "IsNotifying", true);
			SetPropertyValue(c, "IsEditable",  true);

			columns.Members.Add(c);

			// Alias.
			//
			if (c.AliasName != null && c.AliasName != c.MemberName)
			{
				var caProp = new Property(
					c.Type,
					c.AliasName,
					new[] { c.MemberName },
					new[] { c.MemberName + " = value;"});

				caProp.Comment.AddRange(columnComments);

				if (GenerateObsoleteAttributeForAliases)
					caProp.Attributes.Add(new Attribute("Obsolete", "\"Use " + c.MemberName + " instead.\""));

				caProp.Attributes.Add(new Attribute("ColumnAlias", "\"" + c.MemberName + "\""));

				columnAliases.Members.Add(caProp);
			}
		}

		t.Members.Add(columns);

		
		if (spcialColumn.Members.Count > 0)
			t.Members.Add(spcialColumn);

		if (columnAliases.Members.Count > 0)
			t.Members.Add(columnAliases);


		//主外键
		if (GenerateAssociations)
		{
			var keys = t.ForeignKeys.Values.ToList();

			if (!GenerateBackReferences)
				keys = keys.Where(k => k.BackReference != null).ToList();

			if (keys.Count > 0)
			{
				var associations = new MemberGroup { Region = "Associations" };

				foreach (var key in keys)
				{
					key.Comment.Add("/ <summary>");
					key.Comment.Add("/ " + key.KeyName);
					key.Comment.Add("/ </summary>");

					if (key.AssociationType == AssociationType.OneToMany)
						key.Type = string.Format(OneToManyAssociationType, key.OtherTable.TypePrefix + ToPascalCase(key.OtherTable.TypeName));
					else
						key.Type = key.OtherTable.TypePrefix + ToPascalCase(key.OtherTable.TypeName);

					var aa = new Attribute("Association");

					aa.Parameters.Add("ThisKey=\""   + string.Join(", ", (from c in key.ThisColumns  select ToPascalCase(c.MemberName)).ToArray()) + "\"");
					aa.Parameters.Add("OtherKey=\""  + string.Join(", ", (from c in key.OtherColumns select ToPascalCase(c.MemberName)).ToArray()) + "\"");
					aa.Parameters.Add("CanBeNull=" + (key.CanBeNull ? "true" : "false"));

					if (key.BackReference != null)
					{
						if (!string.IsNullOrEmpty(key.KeyName))
							aa.Parameters.Add("KeyName=\"" + key.KeyName + "\"");
						if (GenerateBackReferences && !string.IsNullOrEmpty(key.BackReference.KeyName))
							aa.Parameters.Add("BackReferenceName=\"" + key.BackReference.MemberName + "\"");
					}
					else
					{
						aa.Parameters.Add("IsBackReference=true");
					}

					key.Attributes.Add(aa);

					SetPropertyValue(key, "IsNotifying", true);
					SetPropertyValue(key, "IsEditable",  true);
					key.Name = ToPascalCase(key.Name);
					associations.Members.Add(key);
				}

				t.Members.Add(associations);
			}
		}

		//生成扩展方法
		if (GenerateFindExtensions && nPKs > 0)
		{
			var PKs         = t.Columns.Values.Where(c => c.IsPrimaryKey).ToList();
			var maxNameLen1 = PKs.Max(c => (int?)c.MemberName.Length) ?? 0;
			var maxNameLen2 = PKs.Take(nPKs - 1).Max(c => (int?)c.MemberName.Length) ?? 0;

			tableExtensions.Members.Add(
				new Method(
					t.TypeName,
					"FindByBk",
					new[] { (string.Format("this IQueryable<{0}> table", t.TypeName)) }
						.Union(PKs.Select(c => c.Type + " " + c.MemberName)),
					new[] { "return table.FirstOrDefault(t =>" }
						.Union(PKs.Select((c,i) => string.Format("\tt.{0}{1} == {0}{3}{2}",
							c.MemberName, LenDiff(maxNameLen1, c.MemberName), i == nPKs - 1 ? ");" : " &&", i == nPKs - 1 ? "" : LenDiff(maxNameLen2, c.MemberName)))))
				{
					IsStatic = true
				});

			tableExtensions.Members.Add(
				new Method(
					"async Task<" + t.TypeName + ">",
					"FindByBkAsync",
					new[] { (string.Format("this IQueryable<{0}> table", t.TypeName)) }
						.Union(PKs.Select(c => c.Type + " " + c.MemberName)),
					new[] { "return await table.FirstOrDefaultAsync(t =>" }
						.Union(PKs.Select((c,i) => string.Format("\tt.{0}{1} == {0}{3}{2}",
							c.MemberName, LenDiff(maxNameLen1, c.MemberName), i == nPKs - 1 ? ");" : " &&", i == nPKs - 1 ? "" : LenDiff(maxNameLen2, c.MemberName)))))
				{
					IsStatic = true
				});
		}

		addType(t);

		if (!string.IsNullOrWhiteSpace(t.AliasTypeName))
		{
			var aClass = new Class(t.AliasTypeName)
			{
				BaseClass = t.TypeName
			};

			if (comments.Count > 0)
				aClass.Comment.AddRange(comments);

			if (GenerateObsoleteAttributeForAliases)
				aClass.Attributes.Add(new Attribute("Obsolete", "\"Use " + t.TypeName + " instead.\""));

			Model.Types.Add(aClass);
		}
	}

	if (defAliases.Members.Count > 0)
		DataContextObject.Members.Add(defAliases);

	foreach (var schema in schemas.Values)
		if (schema.Aliases.Members.Count > 0)
			schema.Type.Members.Add(defAliases);

    //存储过程
	if (Procedures.Count > 10000)
	{
		Model.Usings.Add("System.Collections.Generic");
		Model.Usings.Add("System.Data");
		Model.Usings.Add("System.Threading.Tasks");
		Model.Usings.Add("AntData.ORM.Data");
		Model.Usings.Add("AntData.ORM.Common");

		var procs = new MemberGroup();
		var funcs = new MemberGroup();
		var tabfs = new MemberGroup { Region = "Table Functions" };

		foreach (var p in Procedures.Values.Where(
			proc => proc.IsLoaded ||
				(proc.IsFunction && !proc.IsTableFunction)))
		{
			var proc = new MemberGroup { Region = p.Name };

			if (p.IsTableFunction)
			{
				var tableAttrs = new List<string>();

				if (DatabaseName != null) tableAttrs.Add("Database=" + '"' + DatabaseName + '"');
				if (p.Schema     != null) tableAttrs.Add("Schema="   + '"' + p.Schema     + '"');

				tableAttrs.Add("Name=" + '"' + p.ProcedureName + '"');

				p.Attributes.Add(new Attribute("Sql.TableFunction", tableAttrs.ToArray()));

				p.Type = "IQueryable<" + p.ResultTable.TypeName + ">";
			}
			else if (p.IsFunction)
			{
				p.IsStatic = true;
				p.Type = p.ProcParameters.Single(pr => pr.IsResult).ParameterType;
				p.Attributes.Add(new Attribute("Sql.Function", "Name=\"" + p.Schema + "."  + p.ProcedureName + "\"", "ServerSideOnly=true"));
			}
			else
			{
				p.IsStatic = true;
				p.Type     = p.ResultTable == null ? "int" : "IEnumerable<" + ToPascalCase(p.ResultTable.TypeName) + ">";
				p.Parameters.Add("this DataConnection dataConnection");
			}

			foreach (var pr in p.ProcParameters.Where(par => !par.IsResult))
				p.Parameters.Add(string.Format("{0}{1} {2}",
					pr.IsOut ? pr.IsIn ? "ref " : "out " : "", pr.ParameterType, pr.ParameterName));

			if (p.IsTableFunction)
			{
				var body = string.Format("return this.GetTable<{0}>(this, (MethodInfo)MethodBase.GetCurrentMethod()", p.ResultTable.TypeName);

				body += p.ProcParameters.Count == 0 ? ");" : ",";

				p.Body.Add(body);

				for (var i = 0; i < p.ProcParameters.Count; i++)
					p.Body.Add("\t" + p.ProcParameters[i].ParameterName + (i + 1 == p.ProcParameters.Count ? ");" : ","));
			}
			else if (p.IsFunction)
			{
				p.Body.Add("throw new InvalidOperationException();");
			}
			else
			{
				var spName = 
					SqlBuilder.BuildTableName(
						new System.Text.StringBuilder(),
						(string)SqlBuilder.Convert(DatabaseName,    LinqToDB.SqlProvider.ConvertType.NameToDatabase),
						(string)SqlBuilder.Convert(p.Schema,        LinqToDB.SqlProvider.ConvertType.NameToOwner),
						(string)SqlBuilder.Convert(p.ProcedureName, LinqToDB.SqlProvider.ConvertType.NameToQueryTable)
					).ToString();

				spName = "\"" + spName.Replace("\"", "\\\"") + "\"";

				var inputParameters  = p.ProcParameters.Where(pp => pp.IsIn). ToList();
				var outputParameters = p.ProcParameters.Where(pp => pp.IsOut).ToList();

				spName += inputParameters.Count == 0 ? ");" : ",";

				var retName = "ret";
				var retNo   = 0;

				while (p.ProcParameters.Any(pp => pp.ParameterName == retName))
					retName = "ret" + ++retNo;

				var hasOut = outputParameters.Any(pr => pr.IsOut);
				var prefix = hasOut ? "var " + retName + " = " : "return ";

				if (p.ResultTable == null)
					p.Body.Add(prefix + "dataConnection.ExecuteProc(" + spName);
				else
				{
					if (p.ResultTable.Columns.Values.Any(c => c.IsDuplicateOrEmpty))
					{
						p.Body.Add("var ms = dataConnection.MappingSchema;");
						p.Body.Add("");
						p.Body.Add(prefix + "dataConnection.QueryProc(dataReader =>");
						p.Body.Add("\tnew " + p.ResultTable.TypeName);
						p.Body.Add("\t{");

						var n          = 0;
						var maxNameLen = p.ResultTable.Columns.Values.Max(c => (int?)c.MemberName.Length) ?? 0;
						var maxTypeLen = p.ResultTable.Columns.Values.Max(c => (int?)c.Type.      Length) ?? 0;

						foreach (var c in p.ResultTable.Columns.Values)
						{
							p.Body.Add(string.Format("\t\t{0}{1} = Converter.ChangeTypeTo<{2}>{3}(dataReader.GetValue({4}), ms),",
								c.MemberName, LenDiff(maxNameLen, c.MemberName), c.Type, LenDiff(maxTypeLen, c.Type), n++));
						}

						p.Body.Add("\t},");
						p.Body.Add("\t" + spName);
					}
					else
					{
						p.Body.Add(prefix + "dataConnection.QueryProc<" + p.ResultTable.TypeName + ">(" + spName);
					}
				}

				var maxLenSchema = inputParameters.Max(pr => (int?)pr.SchemaName.   Length) ?? 0;
				var maxLenParam  = inputParameters.Max(pr => (int?)pr.ParameterName.Length) ?? 0;
				var maxLenType   = inputParameters.Max(pr => (int?)("DataType." + pr.DataType).Length) ?? 0;

				for (var i = 0; i < inputParameters.Count; i++)
				{
					var pr = inputParameters[i];

					var str = string.Format("\tnew DataParameter(\"{0}\", {1}{2}, {3}{4})",
						pr.SchemaName,
						LenDiff(maxLenSchema, pr.SchemaName),
						pr.ParameterName,
						LenDiff(maxLenParam, pr.ParameterName),
						"DataType." + pr.DataType);

					if (pr.IsOut)
					{
						str += LenDiff(maxLenType, "DataType." + pr.DataType);
						str += " { Direction = " + (pr.IsIn ? "ParameterDirection.InputOutput" : "ParameterDirection.Output");

						if (pr.Size != null && pr.Size.Value != 0)
							str += ", Size = " + pr.Size.Value;

						str += " }";
					}

					str += i + 1 == inputParameters.Count ? ");" : ",";

					p.Body.Add(str);
				}

				if (hasOut)
				{
					maxLenSchema = outputParameters.Max(pr => (int?)pr.SchemaName.   Length) ?? 0;
					maxLenParam  = outputParameters.Max(pr => (int?)pr.ParameterName.Length) ?? 0;
					maxLenType   = outputParameters.Max(pr => (int?)pr.ParameterType.Length) ?? 0;

					p.Body.Add("");

					foreach (var pr in p.ProcParameters.Where(_ => _.IsOut))
					{
						var str = string.Format("{0} {1}= Converter.ChangeTypeTo<{2}>{3}(((IDbDataParameter)dataConnection.Command.Parameters[\"{4}\"]).{5}Value);",
							pr.ParameterName,
							LenDiff(maxLenParam,  pr.ParameterName),
							pr.ParameterType,
							LenDiff(maxLenType,   pr.ParameterType),
							pr.SchemaName,
							LenDiff(maxLenSchema, pr.SchemaName));

						p.Body.Add(str);
					}

					p.Body.Add("");
					p.Body.Add("return " + retName + ";");
				}
			}

			if (p.ResultTable != null && p.ResultTable.DataContextPropertyName == null)
			{
				var columns = new MemberGroup { IsCompact = true };

				foreach (var c in p.ResultTable.Columns.Values)
				{
					if (c.MemberName != c.ColumnName)
						c.Attributes.Add(new Attribute("Column") { Parameters = { '"' + c.ColumnName + '"' } });
					columns.Members.Add(c);
				}

				p.ResultTable.Members.Add(columns);
				proc.Members.Add(p.ResultTable);
			}

			proc.Members.Add(p);

			     if (!p.IsFunction)     procs.Members.Add(proc);
			else if (p.IsTableFunction) tabfs.Members.Add(proc);
			else                        funcs.Members.Add(proc);
		}

		if (procs.Members.Count > 0)
			Model.Types.Add(new Class(DataContextObject.Name + "StoredProcedures", procs) { IsStatic = true });

		if (funcs.Members.Count > 0)
			Model.Types.Add(new Class("SqlFunctions", funcs) { IsStatic = true });

		if (tabfs.Members.Count > 0)
			DataContextObject.Members.Add(tabfs);
	}

	if (defTableExtensions.Members.Count > 0)
	{
		Model.Usings.Add("System.Linq");
		Model.Usings.Add("System.Threading.Tasks");
		Model.Types.Add(new Class("TableExtensions", defTableExtensions) { IsStatic = true });
	}

	foreach (var schema in schemas.Values)
	{
		Model.Types.Add(schema.Type);

		if (schema.TableExtensions.Members.Count > 0)
		{
			Model.Usings.Add("System.Linq");
			Model.Usings.Add("System.Threading.Tasks");
			schema.Type.Members.Add(schema.TableExtensions);
		}
	}

	Tables.    Clear();
	Procedures.Clear();

	Model.SetTree();

	AfterGenerateLinqToDBModel();
}
#>
